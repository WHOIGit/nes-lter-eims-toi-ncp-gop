---
title: "NES-LTER EIMS TOI and NCP-GOP Transects"
author: "Jaxine Wolfe, Kate Morkeski, Stace Beaulieu"
date: "July 27, 2021"
output: html_document
---

## R Markdown Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)

# set environment timezone to UTC
Sys.setenv(TZ = "UTC")

#set path to root of project
library(here)
here("nes-lter-eims-toi-ncp-gop")

# define source for functions developed for the EDI packaging workflow
source("edi-utilities.R")

# define R packages to require
libs <- c("tidyverse", "readxl", "lubridate", "devtools", "EMLassemblyline", "EML", "maps", "xml2")
# load libraries
lapply(libs, require, character.only = TRUE)
```

## EIMS-TOI-TRANSECT DATA ------------

## Read in Provided CSV Files

```{r}

#read in PI-provided csv data
toi_input <- read_csv("eims-toi-transect/bottleEN617withoutincubation.csv", col_names = FALSE)
eims_transect_input <- read_csv("eims-toi-transect/RaEn617withbiosat.csv", col_names = FALSE)

#provide column names
colnames(toi_input) <- c("datetime_utc_matlab", "O2_Ar_delta", "O2_Ar_ratio", "depth_matlab", "cap_Delta_17", "delta_17", "delta_18", "niskin")
colnames(eims_transect_input) <- c("datetime_utc_matlab", "O2_Ar_ratio", "temp", "sal", "latitude_matlab", "longitude_matlab", "cumulative_dist", "biosat")
eims_transect_input <- eims_transect_input %>% select(-temp, -sal, -cumulative_dist)
eims_transect_input$depth <- 5
                           
#convert datetime format
toi_input$datetime_utc_matlab <- as.POSIXct(toi_input$datetime_utc_matlab, format="%d-%b-%Y %H:%M:%OS")
eims_transect_input$datetime_utc_matlab <- as.POSIXct(eims_transect_input$datetime_utc_matlab, format="%d-%b-%Y %H:%M:%OS")

```

# Initial QA for input csv data. 

```{r}

# plot values to check for outliers

ggplot(eims_transect_input, aes(x= datetime_utc_matlab, y = biosat))+ geom_point()
ggplot(eims_transect_input, aes(x= datetime_utc_matlab, y = O2_Ar_ratio))+ geom_point()

ggplot(toi_input, aes(x= datetime_utc_matlab, y = O2_Ar_ratio))+ geom_point()
ggplot(toi_input, aes(x= datetime_utc_matlab, y = O2_Ar_delta))+ geom_point()
ggplot(toi_input, aes(x= datetime_utc_matlab, y = cap_Delta_17))+ geom_point()

# map check
map_locs(df = eims_transect_input, xvar = "longitude_matlab", yvar = "latitude_matlab", region = "transect", colorvar = NULL)

```
## Round columns. Is this still needed? 

```{r}

# 
# #round colunns
# # round datetime_utc_matlab also? 
# ra <- ra %>%
#   mutate(latitude = round(latitude, 4)) %>% 
#   mutate(longitude = round(longitude, 4)) %>% 
#   mutate(temp = round(temp, 3))  %>%
#   mutate(sal = round(sal, 3))  %>%
#   mutate(biosat = round(biosat, 3))  %>%
#   mutate(O2_Ar_ratio = round(O2_Ar_ratio, 4)) 

```

```{r}

# rename csv input data to df names bottle and ra #change these names after checking errors

ra <- eims_transect_input
bottle <- toi_input

```
  
# TOI Underway vs. Bottle

Add a toi_source field to the bottle dataset to clarify whether a bottle was sampled from niskin vs. underway water. Assign underway sampling to a depth of 5m.

```{r}

# define bottle vs underway based on niskin
toi_source <- ifelse(bottle$niskin == 0, 
                     yes = "toi_underway", no = "toi_niskin")
# add categorical column to data
bottle$toi_source <- toi_source

# assign NA to niskin bottle 0
bottle$niskin[bottle$niskin == 0] <- NA_integer_

# assign depths of 0 as 5m if it was an underway sample
for (j in 1:nrow(bottle)) {
  if (bottle$depth_matlab[j] == 0 &
      bottle$toi_source[j] == "toi_underway") {
    bottle$depth_matlab[j] <- 5
  } else {
    j <- j + 1
    next
  }
}

```

## Correct UTC datetime and depth for bottle samples

Issues: 
  • The datetime_utc for bottle-sampled data represents the cast start time, NOT the time at which the bottle was fired
  • Differences in the given depth vs. those in the bottle summary

Solution: 
  • load in the bottle summary for the appropriate cruise
  • find the associated cast based on nearest time
  • find the time at which the bottle was fired based on cast and niskin
  • find associated depth based on nearest time
  • compare the given depth to api provided
  
```{r}

# read in bottle summary for en617
summary <- read_from_api(type = "summary", cruises = "EN617")

#rename depth column in bottle file
#bottle <- rename(bottle, depth_matlab = depth)

# create column to populate with k from high throughput
bottle$cast <- NA_integer_
bottle$depth_api <- NA_integer_

for (i in 1:nrow(bottle)) {
  # store values
  nisk <- bottle$niskin[i]
  sampletime <- bottle$datetime_utc_matlab[i]
  
  # skip row if underway
  if (is.na(nisk)) {
    i <- i + 1
    next
  }
  
  # find the index of the nearest datetime
  ind <- which.min(abs(sampletime - summary$date))
  smry_cast <- summary$cast[ind]

  # populate cast column from summary
  bottle$cast[i] <- smry_cast
  
  # store cast to find bottle time
  smry <- summary %>% filter(cast == smry_cast &
                               niskin == nisk)
  
  # case: smry subset is empty
  if (nrow(smry) == 0) {
    print(paste0("Niskin ", nisk, " not found in bottle summary for cast ", smry_cast))
    i <- i + 1
    next
  }
  
  # store bottle time 
  bottle$datetime_utc[i] <- smry$date
  bottle$depth_api[i] <- smry$depth
}

# convert API date time from seconds to POXIX ## need to check that this conversion is correct
 bottle$datetime_utc <- as.POSIXct(bottle$datetime_utc, origin = "1970-01-01", tz = "GMT")

# isolate instances of large depth differences
bottle$depth_diff <- bottle$depth_matlab - bottle$depth_api
depth_conflicts <- bottle %>% filter(depth_diff > 5 | depth_diff < -5)

bottle <- rename(bottle, depth_API_bottle_summary = depth_api)

# write.csv(depth_conflicts, "bottle-depth-conflicts.csv")
```

## Supply lat/lon for bottles data from underway api

Using the corrected datetimes, pull geospatial data from the underway log

```{r}

underway <- read_from_api(type = "underway", cruises = "EN617")

# match to datetime
# figure out which lat/lon to use

# for toi file
bottle$latitude <- NA_integer_
bottle$longitude <- NA_integer_

for (i in 1:nrow(bottle)) {
  # store values
  sampletime <- bottle$datetime_utc[i]
  
  # find the index of the nearest datetime
  ind <- which.min(abs(sampletime - underway$date))
  
  # store bottle time 
  bottle$latitude[i] <- underway$gps_furuno_latitude[ind]
  bottle$longitude[i] <- underway$gps_furuno_longitude[ind]
}

# for eims file
ra$latitude_API <- NA_integer_
ra$longitude_API <- NA_integer_

for (i in 1:nrow(bottle)) {
  # store values
  sampletime <- ra$datetime_utc_matlab[i]
  
  # find the index of the nearest datetime
  ind <- which.min(abs(sampletime - underway$date))
  
  # store bottle time 
  ra$latitude_API[i] <- underway$gps_furuno_latitude[ind]
  ra$longitude_API[i] <- underway$gps_furuno_longitude[ind]
}


```

## Round columns. Is this still needed? 

```{r}

# round numeric columns
# round datetime_utc_matlab also? 
# bottle <- bottle %>%
#   mutate(latitude = round(latitude, 4)) %>% 
#   mutate(longitude = round(longitude, 4)) %>% 
#   mutate(depth_matlab = round(depth_matlab, 3))  %>%
#   mutate(depth_API_bottle_summary = round(depth_API_bottle_summary, 3))  %>%
#   mutate(O2_Ar_delta = round(O2_Ar_delta, 4)) %>% 
#   mutate(O2_Ar_ratio = round(O2_Ar_ratio, 4)) %>% 
#   mutate(cap_Delta_17 = round(cap_Delta_17, 4)) %>% 
#   mutate(delta_17 = round(delta_17, 4)) %>% 
#   mutate(delta_18 = round(delta_18, 4))

```


## QA: Checking Data Integrity
```{r}

# are there any niskins where the depth is 0?
if (any(bottle$depth_matlab == 0)) {
  conflicts <- bottle[which(bottle$depth_matlab == 0),]
  print(conflicts)
}

# write.csv(conflicts, "bottlesamples_conflict.csv")
# write.csv(summary, "bottlesummary_EN617.csv")

# why do we have this line? 
summary %>% filter(cast == 14 | cast == 29)

```

## QA: Map Sampling Locations

Call the map_locs function from edi-utility.R to map the sampling locations. Perform a visual check.

```{r}

# Map Check

# bottle
map_locs(df = bottle, xvar = "longitude", yvar = "latitude",
         region = "transect", colorvar = NULL)

# underway 02/Ar  # trying to plot both sets together. Not working quite right. 
map_locs(df = ra, xvar = "longitude_matlab", yvar = "latitude_matlab",
         region = "transect", colorvar = as.factor("latitude_matlab")) + geom_point(df = ra, xvar = "longitude_API", yvar = "latitude_API",
         region = "transect", color = as.factor("blue"))

# plotting eims matlab lat long
map_locs(df = ra, xvar = "longitude_matlab", yvar = "latitude_matlab",
         region = "transect", colorvar = as.factor("latitude_matlab")) 

# plotting eims lat long from API # most locations do not have API lat long. Need to find out why. 
map_locs(df = ra, xvar = "longitude_API", yvar = "latitude_API",
         region = "transect", colorvar = as.factor("latitude_API")) 


```

## Column Header Organization

```{r}

# define headers for columns in desired order
bottle_headers <- c("datetime_utc_matlab","datetime_utc", "latitude", "longitude", "toi_source", "cast", "niskin", "depth_matlab", "depth_API_bottle_summary", "O2_Ar_delta", "O2_Ar_ratio", "cap_Delta_17", "delta_17", "delta_18")
ra_headers <- c("datetime_utc_matlab", "latitude_matlab", "longitude_matlab", "latitude_API", "longitude_API", "depth", "biosat", "O2_Ar_ratio")

# reorder columns as necessary
bottle_edi <- bottle[, bottle_headers]
ra_edi <- ra[, ra_headers]

# write files for upload to EDI
write.csv(bottle_edi, here("eims-toi-transect", 'toi-transect.csv'), row.names = FALSE)
write.csv(ra_edi, here("eims-toi-transect", 'eims-transect.csv'), row.names = FALSE)

```

# EML Assembly: EIMS-TOI-transect

This chunk outputs the final xml file for EDI through the following steps:

Step 1: Populating EML Assembly Line templates with metadata
Step 2: Calculating the geospatial and temporal coverage 
Step 3: Making the XML file 
Step 4: Inserting a custom NES-LTER parent project node 

```{r}

# define input for EML assembly
metadata <- "eims-toi-transect/eims-toi-transect-info"
project_folder <- "eims-toi-transect/"
bottles_file <- "toi-transect"
ra_file <- "eims-transect"
edi_data <- c(bottles_file, ra_file)
file_descriptions <- c("Data product low-frequency triple oxygen isotopes and oxygen-argon ratio from surface rosette and underway bottles", "Data product high-frequency oxygen-argon dissolved gas ratio and biosaturation from underway EIMS measurements")
pkg_id <- "knb-lter-nes.6.1"
matlab_bottle_file <- "bottleEn617withoutincubation" 
matlab_rates_file <- "RaEn617withbiosat"
matlab_data <- c(("bottleEn617withoutincubation.mat"), ("RaEn617withbiosat.mat")) #if in same folder

# Make EML Templates 
xlsx_to_template(metadata.path = metadata,
                 output.path = project_folder,
                 edi.filename = NULL, 
                 rights = "CCBY")
# toi bottle samples
xlsx_to_template(metadata.path = here(project_folder, bottles_file), 
                 output.path = project_folder,
                 edi.filename = bottles_file, 
                 rights = "CCBY")
# underway samples
xlsx_to_template(metadata.path = here(project_folder, ra_file), 
                 output.path = project_folder,
                 edi.filename = ra_file, 
                 rights = "CCBY")

# Data Coverage
# combine the dates for both datasets
# isolate date and geospatial columns for input
date_col <- as.Date(c(ra_edi$datetime_utc_matlab,
                      bottle_edi$datetime_utc))
lat_col <- ra_edi$latitude
lon_col <- ra_edi$longitude
# run function to determine geospatial and temporal coverage
coverage <- data_coverage(dates = date_col, lat = lat_col, lon = lon_col)

# Make EML
make_eml(path = project_folder,
         dataset.title = "Oxygen-argon dissolved gas ratios and triple oxygen isotopes from NES-LTER Transect cruises, ongoing since 2018",
         data.table = c(paste0(bottles_file, ".csv"), paste0(ra_file, ".csv")),
         data.table.name = c(paste0(bottles_file, ".csv"), paste0(ra_file, ".csv")),
         data.table.description = file_descriptions,
         other.entity = matlab_data,
         other.entity.name = c(paste0(matlab_bottle_file, ".mat"), paste0(matlab_rates_file, ".mat")),
         other.entity.description = c("Package input bottle sample triple oxygen isotopes and oxygen-argon ratio from surface rosette and underway bottles", "Package input high-frequency oxygen-argon dissolved gas ratio and biosaturation from underway EIMS measurements"), 
         temporal.coverage = c(coverage$startdate, coverage$enddate),
         geographic.description = "NES-LTER Transect",
         geographic.coordinates = c(coverage$North, coverage$East, coverage$South, coverage$West),
         maintenance.description = "ongoing",
         user.id = "NES",
         user.domain = "LTER",
         package.id = pkg_id)

# Insert Custom Project Node
project_insert(edi_pkg = pkg_id, 
               xml.path = project_folder)
```


## NCP-GOP-TRANSECT ----------

# Define column headers

Columns are named according to the description of the provided .mat files.

```{r}
# # assign column headers
# colnames(ncplterEn617) <- c("datetime_utc_matlab", "O2_Ar_ratio", "temp", "sal", "latitude", "longitude",
#                 "cum_dist", "biosat", "ncp", "k","datetime_utc")
# colnames(discreteratesEn617) <- c("datetime_utc_matlab", "latitude", "longitude", "gop", "ncp", "ncp_per_gop","datetime_utc")
# #matlab input should also include depth_mat_file to enable TOI source identification
# #for now create that column 
# discreteratesEn617$depth_mat_file <- NA_integer_
# 
# # trim unnecessary fields and rename vars
# ncplter <- ncplterEn617 %>% select(-cum_dist)
# rates <- discreteratesEn617
# # add depth column to high freq EIMS data
# ncplter$depth <- 5

```
## Read in Provided CSV Files

```{r}

#read in PI-provided csv data
ncpgop_input <- read_csv("ncp-gop-transect-summer-2018/discreteratesEn617.csv", col_names = FALSE)
ncp_hifreq_input <- read_csv("ncp-gop-transect-summer-2018/ncplterEN617.csv", col_names = FALSE)

#provide column names
colnames(ncp_hifreq_input) <- c("datetime_utc", "O2_Ar_ratio", "temp", "sal", "latitude", "longitude", "cumulative_dist", "biosat", "ncp", "k")
colnames(ncpgop_input) <- c("datetime_utc", "latitude", "longitude", "gop", "ncp","ncp_per_gop")
ncp_hifreq_input <- ncp_hifreq_input %>% select(-cumulative_dist)
#eims_transect_input$depth <- 5

#input should also include depth_matlab to enable TOI source identification
#for now create that column 
ncpgop_input$depth_matlab <- NA_integer_

# add depth column to high freq EIMS data
ncp_hifreq_input$depth <- 5

                           
#convert datetime format
ncpgop_input$datetime_utc <- as.POSIXct(ncpgop_input$datetime_utc, format="%d-%b-%Y %H:%M:%OS")
ncp_hifreq_input$datetime_utc <- as.POSIXct(ncp_hifreq_input$datetime_utc, format="%d-%b-%Y %H:%M:%OS")

```

```{r}
# rename csv input data to df names bottle and ra #change these names after checking errors

ncplter <- ncp_hifreq_input
rates <- ncpgop_input

```


# Round columns

```{r}

#round colunns
# round datetime_utc_matlab also? 
ncplter <- ncplter %>%
  mutate(latitude = round(latitude, 4)) %>% 
  mutate(longitude = round(longitude, 4)) %>% 
  mutate(temp = round(temp, 3))  %>%
  mutate(sal = round(sal, 3))  %>%
  mutate(biosat = round(biosat, 3))  %>%
  mutate(O2_Ar_ratio = round(O2_Ar_ratio, 4))  %>%
  mutate(ncp = round(ncp, 3))  %>%
  mutate(k = round(k, 3)) 

rates <- rates %>%
  mutate(latitude = round(latitude, 4)) %>% 
  mutate(longitude = round(longitude, 4)) %>% 
  mutate(gop = round(gop, 3))  %>%
  mutate(ncp = round(ncp, 3))  %>%
  mutate(ncp_per_gop = round(ncp_per_gop, 3)) 

```

# Join with TOI data to identify TOI_source

```{r}

#after datetime is updated (and lat/long too?), join rates and bottle_edi on datetime and depth_mat_file to acquire toi_source from bottle_edi

rates$toi_source <- NA_character_ #this won't be needed when join is working

#rates_source <- left_join(rates, bottle_edi, by = c('datetime_utc_matlab' , 'latitude', 'longitude'))
#inspect result

#rates_source <- rates_source %>% select (-datetime_utc.x, -depth_mat_file.x, -datetime_utc.y, -cast, -niskin, -depth_mat_file.y, -depth_API_bottle_summary, -O2_Ar_delta, -O2_Ar_ratio, -cap_Delta_17, -delta_17, delta_18)
#keep depth_API_bottle_summary column after this join or remove it?

```

## QA: Map Sampling Locations

Call the map_locs function from edi-utility.R to map the sampling locations. Perform a visual check.

```{r}

# Map Check

# ncplter
map_locs(df = ncplter, xvar = "longitude", yvar = "latitude",
         region = "transect", colorvar = NULL)

# discrete rates
map_locs(df = ncplter, xvar = "longitude", yvar = "latitude",
         region = "transect", colorvar = NULL)

```

# Column Header Organization
```{r}

# define the desired order of columns
rates_headers <- c("datetime_utc", "latitude", "longitude", "toi_source", "gop", "ncp", "ncp_per_gop")
ncp_headers <- c("datetime_utc", "latitude", "longitude", "depth", "biosat", "O2_Ar_ratio", "ncp", "k")

# reorder columns as necessary
rates_edi <- rates[, rates_headers]
ncplter_edi <- ncplter[, ncp_headers]

# write files for upload to EDI
write.csv(rates_edi, here("ncp-gop-transect-summer-2018", "gop-transect-en617.csv"), row.names = FALSE)
write.csv(ncplter_edi, here("ncp-gop-transect-summer-2018", "ncp-transect-en617.csv"), row.names = FALSE)

```


# EML Assembly: NCP-GOP-transect (Per Cruise)

This chunk outputs the final xml file for EDI through the following steps:

Step 1: Populating EML Assembly Line templates with metadata
Step 2: Calculating the geospatial and temporal coverage 
Step 3: Making the XML file 
Step 4: Inserting a custom NES-LTER parent project node 

```{r}

# define input for EML assembly
metadata <- "ncp-gop-transect-summer-2018/ncp-gop-transect-summer-2018-info"
project_folder <- "ncp-gop-transect-summer-2018/"
rates_file <- "gop-transect-en617"
ncp_file <- "ncp-transect-en617"
edi_data <- c(rates_file, ncp_file)
file_descriptions <- c("Data product discrete rates of NCP and GOP from bottle TOI measurements integrated over the mixed layer", "Data product high frequency NCP derived from EIMS sampling of underway seawater")
pkg_id <- "knb-lter-nes.7.1"

# Make EML Templates 
xlsx_to_template(metadata.path = metadata,
                 output.path = project_folder,
                 edi.filename = NULL, 
                 rights = "CCBY")
# Discrete Rates
xlsx_to_template(metadata.path = here(project_folder, rates_file), 
                 output.path = project_folder,
                 edi.filename = rates_file, 
                 rights = "CCBY")
# Ncplter 
xlsx_to_template(metadata.path = here(project_folder, ncp_file), 
                 output.path = project_folder,
                 edi.filename = ncp_file, 
                 rights = "CCBY")

# Data Coverage
# combine the dates and lat/lon for both datasets
# isolate date and geospatial columns for input
date_col <- as.Date(c(ncplter_edi$datetime_utc, rates_edi$datetime_utc))
lat_col <- c(ncplter_edi$latitude, rates_edi$latitude)
lon_col <- c(ncplter_edi$longitude, rates_edi$longitude)
# run function to determine geospatial and temporal coverage
coverage <- data_coverage(dates = date_col, lat = lat_col, lon = lon_col)

# Make EML
make_eml(path = project_folder,
         dataset.title = "Net community production and gross oxygen production, based on oxygen-argon ratios and triple oxygen isotopes, from NES-LTER Transect cruise summer 2018",
         data.table = c(paste0(rates_file, ".csv"), paste0(ncp_file, ".csv")),
         data.table.name = paste0(edi_data, ".csv"),
         data.table.description = file_descriptions,
         other.entity = c('ncplterEn617.mat', 'discreteratesEn617.mat'),
         other.entity.description = c("Package input high frequency NCP derived from EIMS sampling of underway seawater", "Package input discrete rates of NCP and GOP from bottle TOI measurements integrated over the mixed layer"),
         temporal.coverage = c(coverage$startdate, coverage$enddate),
         geographic.description = "NES-LTER Transect",
         geographic.coordinates = c(coverage$North, coverage$East, coverage$South, coverage$West),
         maintenance.description = "completed",
         user.id = "NES",
         user.domain = "LTER",
         package.id = pkg_id)

# Insert Custom Project Node
project_insert(edi_pkg = pkg_id, 
               xml.path = project_folder)
```
 
